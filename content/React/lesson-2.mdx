---
id: CF-2103
title: Lesson 2 Components as Pure Descriptions Not Procedures
classification: UNCLASSIFIED
status: ACTIVE
updatedAt: 2025-12-16T16:15:00.000Z
owner: Frontend Systems Education
role: Curriculum Author
timeframe: 1 lesson
stack:
  - React
  - JavaScript
  - JSX
tags:
  - React Core
  - Component Model
  - Declarative Architecture
  - Pure Functions
  - Unidirectional Data Flow
  - UI Composition
  - State Ownership
  - Predictable Rendering
  - Frontend Foundations
links:
  - label: Lesson One
    href: lesson-one.mdx
summary: Explains React components as pure descriptive units of UI that compose into a deterministic tree, replacing procedural DOM logic with predictable data flow and isolated responsibility.
---

# **Lesson 2 — Components as Pure Descriptions, Not Procedures**

---

### **Context / Motivation**

In Lesson 1, we saw that React’s power lies in its **declarative model** — you describe _what_ the UI should look like for a given state, and React figures out _how_ to make it happen.

But that raises the next question:

> How do we organize large UIs so that each part stays predictable and independent?

Early DOM-based applications often used long procedural scripts manipulating many elements. Changing one feature could unintentionally break another.
React solved this with **components** — but to understand why, we must see what went wrong before.

---

### **The Problem: Entangled UI Logic**

Suppose you’re building a dashboard that greets a user and shows their task count.

```html
<div id="root">
  <p id="greeting"></p>
  <p id="tasks"></p>
</div>

<script>
  const user = { name: "Nasser", tasks: 3 };
  const greetingEl = document.getElementById("greeting");
  const tasksEl = document.getElementById("tasks");

  function render() {
    greetingEl.textContent = `Hello, ${user.name}!`;
    tasksEl.textContent = `You have ${user.tasks} tasks.`;
  }

  render();
```

At first, this is fine.
But soon someone adds:

- An “Add task” button
- A “Mark complete” option
- A “Task List” table

Now, every time `user.tasks` changes, you must **manually update several parts** of the DOM.
The logic becomes tangled: _where_ does one feature end and another begin?

There is no _unit of UI responsibility_.

---

### **The React Insight: Components as Units of Description**

React introduced a new organizing principle:

> A **component** is a _pure function_ that describes a piece of UI for a given set of inputs.

Each component:

- Receives **props** (inputs)
- Produces **a description of UI** (JSX)
- Can be composed of smaller components

Let’s refactor the previous example into React components.

---

### **Example: From Entangled Code to Components**

```jsx
function Greeting({ name }) {
  return <p>Hello, {name}!</p>;
}

function TaskCount({ tasks }) {
  return <p>You have {tasks} tasks.</p>;
}

function Dashboard() {
  const user = { name: "Nasser", tasks: 3 };

  return (
    <div>
      <Greeting name={user.name} />
      <TaskCount tasks={user.tasks} />
    </div>
  );
}

ReactDOM.createRoot(document.getElementById("root")).render(<Dashboard />);
```

Each component is:

- **Pure:** same input → same output
- **Isolated:** it doesn’t depend on or mutate global state
- **Composable:** small parts combine into a larger UI

React can now re-render just the part that changed — e.g., if `user.tasks` updates, only `<TaskCount>` needs to refresh.

---

### **How Components Build a Declarative Tree**

When React renders `<Dashboard />`, it internally builds a _tree_ of descriptions:

```
Dashboard
 ├─ Greeting
 │   └─ <p>Hello, Nasser!</p>
 └─ TaskCount
     └─ <p>You have 3 tasks.</p>
```

This tree acts as a **declarative snapshot** of the UI state.

If the data changes, React runs each function again, producing a new tree — then compares it to the previous one and applies the minimal DOM updates.

Each node in the tree corresponds to a component that _describes its own part of reality_.

---

### **The Principle of Unidirectional Data Flow**

To keep this model predictable, React enforces **one-way data flow**:

- Parent components pass data _down_ through props.
- Child components cannot directly modify parent data.
- Updates happen through explicit state changes.

This solves a major source of bugs in early frameworks: _implicit bidirectional binding._

Let’s see this visually:

```
App (state)
  ↓
Child A (props)
  ↓
Child B (props)
```

All data moves _downward_, all events move _upward_ through callbacks.

---

### **Example: Controlled Flow of Updates**

```jsx
function Counter() {
  const [count, setCount] = React.useState(0);

  return (
    <div>
      <Display count={count} />
      <Increment onClick={() => setCount(count + 1)} />
    </div>
  );
}

function Display({ count }) {
  return <p>Count: {count}</p>;
}

function Increment({ onClick }) {
  return <button onClick={onClick}>+</button>;
}
```

Here:

- `Counter` holds the _source of truth_ (`count`)
- It passes data _down_ to `Display`
- It passes _behavior_ down to `Increment`

This makes the data graph **explicit and predictable**.
Every render is a fresh, pure description of the UI — no mutation, no shared state.

---

### **Why This Model Scales**

In large systems, you can:

- Split complex screens into nested, testable components.
- Reuse UI logic by composing components.
- Replace or rearrange parts of the tree without side effects.

This makes React **structurally scalable** — not just in performance, but in reasoning.

---

### **Common Mistake: Treating Components as Procedures**

Beginners sometimes try to “call” components like functions to _execute_ logic:

```jsx
// ❌ Misuse
function App() {
  const element = Display({ count: 5 }); // this skips React’s reconciliation!
  return element;
}
```

This breaks React’s lifecycle and diffing, because React expects components to _describe_, not _perform_.
Always **use JSX** (`<Display count={5} />`) so React knows how to track changes across renders.

---

### **Evolution / Refinement**

Originally, React used **class components** to encapsulate state and lifecycle.
With time, React introduced **function components** and **hooks**, because they’re closer to the mathematical idea of “pure functions of state.”

Components evolved from:

- “Objects with lifecycle methods”
  → to “pure render functions with declarative memory.”

We’ll study that transition in the next lessons.

---

### **Principle / Takeaway**

> **Components are pure descriptive functions.**
> They exist not to _do_ things, but to _describe_ what the UI should look like, given the current data.

The flow is always:

```
Props (inputs) → Component → JSX (description)
```

By enforcing purity and unidirectional data flow, React ensures your UI stays consistent, predictable, and scalable — the same principles that later make hooks and concurrency possible.

---

Next, we’ll move to **Lesson 3 — State: Remembering Across Renders**, where we’ll see how React introduced “state” to let components _remember_ over time while preserving purity?
