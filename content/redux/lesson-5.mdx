---
id: CF-3005
title: Lesson 5 From Vanilla Redux to Redux Toolkit Motivation and Design Goals
classification: UNCLASSIFIED
status: ACTIVE
updatedAt: 2025-12-16T22:20:00.000Z
owner: Frontend Systems Education
role: Curriculum Author
timeframe: 1 lesson
stack:
  - JavaScript
  - Redux
  - Redux Toolkit
  - Immer
tags:
  - Redux
  - Redux Toolkit
  - State Management
  - Boilerplate Reduction
  - Immutability
  - Async State
  - Developer Ergonomics
  - Frontend Architecture
  - Unidirectional Data Flow
links:
  - label: Lesson Four
    href: redux-lesson-four.mdx
summary: Explains why Redux Toolkit was created, identifying the pain points of vanilla Redux and showing how RTK codifies best practices to reduce boilerplate, simplify immutability, and streamline async workflows without changing Redux’s core architecture.
---

# **Lesson 5 — From Vanilla Redux to Redux Toolkit (RTK): Motivation and Design Goals**

---

## **Context / Motivation**

By now, you understand how **vanilla Redux** works internally — the store, actions, reducers, and middleware.
It’s elegant in theory but… often _tedious in practice._

When Redux first gained popularity (around 2015–2017), developers quickly discovered a paradox:

> Redux made large applications easier to reason about — but harder to _write._

To define even a simple feature, you needed:

- A constant for the action type.
- An action creator function.
- A reducer function handling that action.
- Sometimes a thunk for async work.
- Then you had to wire them all into a store with `combineReducers()` and `applyMiddleware()`.

Each piece was small and clear, but together they created **a lot of boilerplate** — repetitive code that added no conceptual value.
Redux Toolkit (RTK) was introduced to **solve this pain**, not by changing Redux’s principles, but by _codifying its best practices_ and _automating its patterns._

---

## **Conceptual Explanation**

### **1. The Problems With Vanilla Redux**

Let’s summarize the main developer pain points:

#### a. **Boilerplate Explosion**

A simple feature like a counter could easily take 30–50 lines:

```js
// actionTypes.js
export const INCREMENT = "INCREMENT";

// actions.js
export function increment() {
  return { type: INCREMENT };
}

// reducer.js
function counterReducer(state = { value: 0 }, action) {
  switch (action.type) {
    case INCREMENT:
      return { value: state.value + 1 };
    default:
      return state;
  }
}
```

This is fine for one or two features. But in a production app with 20+ modules, it becomes exhausting.

---

#### b. **Immutability by Hand**

Redux requires reducers to be pure and not mutate state.
This means you constantly write verbose copying logic:

```js
return {
  ...state,
  todos: state.todos.map((todo) =>
    todo.id === action.payload.id ? { ...todo, done: true } : todo
  ),
};
```

Doing this everywhere is error-prone and mentally heavy.

---

#### c. **Async Flow Management**

Handling async actions meant manually tracking three states:

- `FETCH_START`
- `FETCH_SUCCESS`
- `FETCH_FAILURE`

and manually setting flags like `loading: true` or `error: null` in your reducers.
It worked, but it wasn’t elegant.

---

#### d. **Inconsistent Patterns**

Different teams wrote Redux differently.
Some used constants, some didn’t.
Some nested reducers by domain, others by feature.
RTK aimed to end these “pattern wars” by offering _one official, recommended way_.

---

### **2. The Philosophy of Redux Toolkit**

Redux Toolkit was designed with three guiding principles:

1. **Reduce Boilerplate**
   Make Redux faster to write and less verbose, while keeping the same mental model.

2. **Encourage Best Practices by Default**
   Set up store configuration, DevTools, and middleware automatically.

3. **Stay 100% Compatible with Redux**
   RTK is not a new library — it’s a _layer on top of Redux_.
   Everything you learned still applies; RTK just builds it more cleanly.

---

### **3. The Core APIs of Redux Toolkit**

Let’s see the three most important building blocks.

#### a. `configureStore()`

Simplifies store creation.

Before:

```js
const store = createStore(rootReducer, applyMiddleware(thunk, logger));
```

With RTK:

```js
import { configureStore } from "@reduxjs/toolkit";

const store = configureStore({
  reducer: rootReducer,
});
```

It automatically includes:

- Redux DevTools support
- Thunk middleware
- Sensible defaults for error handling

---

#### b. `createSlice()`

This is RTK’s crown jewel.
It combines **actions** and **reducers** into one logical unit — a “slice” of state.

Example:

```js
import { createSlice } from "@reduxjs/toolkit";

const counterSlice = createSlice({
  name: "counter",
  initialState: { value: 0 },
  reducers: {
    increment: (state) => {
      state.value += 1;
    },
    decrement: (state) => {
      state.value -= 1;
    },
    incrementByAmount: (state, action) => {
      state.value += action.payload;
    },
  },
});
```

This automatically generates:

- The reducer function (`counterSlice.reducer`)
- The action creators (`counterSlice.actions.increment`, etc.)

Notice something new:
You **mutate state directly** — `state.value += 1` — but Redux Toolkit uses **Immer** under the hood, which converts those mutations into _immutable updates_ safely.

So you write code like a normal person, but still get immutability guarantees.

---

#### c. `createAsyncThunk()`

Simplifies asynchronous logic.

Before:

```js
function fetchUsers() {
  return async function (dispatch) {
    dispatch({ type: "FETCH_USERS_START" });
    const res = await fetch("/api/users");
    const data = await res.json();
    dispatch({ type: "FETCH_USERS_SUCCESS", payload: data });
  };
}
```

With RTK:

```js
import { createAsyncThunk } from "@reduxjs/toolkit";

export const fetchUsers = createAsyncThunk("users/fetch", async () => {
  const res = await fetch("/api/users");
  return await res.json();
});
```

RTK automatically dispatches `pending`, `fulfilled`, and `rejected` actions for you.
You simply handle them in your slice’s `extraReducers`.

---

### **4. The Result**

A counter example that used to take 30 lines can now be written in ~10 lines, _without losing clarity._

RTK doesn’t add “magic.” It just integrates the patterns you would have written by hand — but faster, safer, and with guardrails.

---

## **Real-World Illustration**

Imagine a medium-sized e-commerce web app.
In vanilla Redux, every new feature (like wishlist, notifications, or coupons) means adding new:

- constants
- action creators
- reducers
- types

Developers end up with scattered files, copy-pasted switch statements, and fragile updates.

Redux Toolkit reorganizes this mess:

- Each **feature** (cart, products, wishlist) becomes a _slice_.
- Each slice manages its own state, actions, and reducers in one place.
- The store just combines all slices via `configureStore`.

This structure scales elegantly — the code grows horizontally (by features), not vertically (by boilerplate).

---

## **Evolution / Refinement**

Redux Toolkit’s introduction (2019) marked a shift in how the Redux ecosystem thinks:

- It preserved the **predictable state model**.
- It introduced **developer ergonomics** comparable to other modern state libraries like MobX, Zustand, or Recoil.
- It paved the way for **RTK Query** — a built-in solution for data fetching and caching.

In short, RTK didn’t change Redux’s principles.
It **evolved its ergonomics** to match modern JavaScript and React development practices.

---

## **Principle / Takeaway**

Redux Toolkit is not a replacement for Redux — it is _Redux done right._

It automates what you would write manually:

- **Slices** instead of action-type juggling.
- **Immer** for safe immutability.
- **Async thunks** for clean side effects.
- **Configured stores** with sane defaults.

It keeps the mental model you’ve learned (single store, unidirectional data flow) — but removes 80% of the friction.

---

✅ **Next Lesson Preview – Lesson 6:**
**Understanding `createSlice()` — Simplifying Reducers and Actions**
We’ll dive into RTK’s most important building block, `createSlice()`.
You’ll learn how it unifies reducers and action creators, how Immer handles immutable updates under the hood, and how to structure slices for real-world apps.
