---
id: CF-3016
title: Lesson 16 Advanced Redux Toolkit Patterns
classification: UNCLASSIFIED
status: ACTIVE
updatedAt: 2025-12-17T01:05:00.000Z
owner: Frontend Systems Education
role: Curriculum Author
timeframe: 1 lesson
stack:
  - JavaScript
  - React
  - Redux
  - Redux Toolkit
  - Entity Adapters
  - RTK Query
tags:
  - Advanced Patterns
  - Entity Adapters
  - Matchers
  - Cross Slice Communication
  - Large Scale State
  - Architecture
  - Maintainability
summary: Covers advanced Redux Toolkit patterns for large scale applications including entity adapters for normalized collections matchers for declarative multi action handling and cross slice communication techniques that enable coordination without tight coupling.
---

# \*\*Lesson 16: Advanced Redux Toolkit Patterns

Entity Adapters, Matchers, and Cross Slice Communication\*\*

---

## **Context and Motivation**

Up to this point, you have learned how to model state with slices, async thunks, selectors, RTK Query, and performance optimizations.
This is enough for many applications.

But in large systems, new problems appear:

• You manage large collections of entities
• Multiple slices react to the same async events
• Data from one feature must influence another feature
• Reducers become repetitive and verbose

Redux Toolkit includes **advanced primitives** that solve these problems without breaking Redux’s core principles.

This lesson focuses on three such tools:

1. Entity adapters for structured collections
2. Matchers for reacting to many actions declaratively
3. Cross slice communication for coordinated state updates

---

## **1. Entity Adapters: Managing Collections at Scale**

### **The Problem**

Collections are everywhere: users, posts, comments, messages, products.

A naive structure looks like this:

```js
{
  users: [
    { id: 1, name: "Alice" },
    { id: 2, name: "Bob" },
  ];
}
```

This causes problems:

• Updates require array scans
• Deletes require filtering
• Selectors become expensive
• Normalization logic is repeated everywhere

Redux Toolkit solves this with **entity adapters**.

---

### **What an Entity Adapter Is**

An entity adapter provides:

• A normalized state shape
• Prebuilt reducers for CRUD operations
• Prebuilt selectors for fast access

The normalized shape looks like:

```js
{
  ids: [1, 2],
  entities: {
    1: { id: 1, name: 'Alice' },
    2: { id: 2, name: 'Bob' }
  }
}
```

---

### **Creating an Entity Adapter**

```js
import { createEntityAdapter, createSlice } from "@reduxjs/toolkit";

const usersAdapter = createEntityAdapter({
  selectId: (user) => user.id,
  sortComparer: (a, b) => a.name.localeCompare(b.name),
});

const usersSlice = createSlice({
  name: "users",
  initialState: usersAdapter.getInitialState({
    status: "idle",
  }),
  reducers: {
    usersAdded: usersAdapter.addMany,
    userUpdated: usersAdapter.updateOne,
    userRemoved: usersAdapter.removeOne,
  },
});
```

You now get powerful reducers for free.

---

### **Entity Adapter Selectors**

```js
export const {
  selectAll: selectAllUsers,
  selectById: selectUserById,
  selectIds: selectUserIds,
} = usersAdapter.getSelectors((state) => state.users);
```

These selectors are memoized and efficient by default.

---

### **When to Use Entity Adapters**

Use them when:

• Collections are large
• Items are updated individually
• You need fast lookup by id
• Sorting consistency matters

Avoid them for small or static lists.

---

## **2. Matchers: Reacting to Groups of Actions**

### **The Problem**

You often write the same reducer logic for many async actions:

```js
builder.addCase(fetchUsers.pending, setLoading);
builder.addCase(fetchPosts.pending, setLoading);
builder.addCase(fetchComments.pending, setLoading);
```

This is repetitive and fragile.

---

### **What Matchers Do**

Matchers let reducers react to **patterns of actions** instead of individual ones.

Redux Toolkit provides helpers like:

• isPending
• isFulfilled
• isRejected

---

### **Using Matchers**

```js
import { isPending, isRejected } from "@reduxjs/toolkit";

extraReducers: (builder) => {
  builder
    .addMatcher(isPending, (state) => {
      state.loading = true;
    })
    .addMatcher(isRejected, (state, action) => {
      state.loading = false;
      state.error = action.error.message;
    });
};
```

Now any async thunk pending or rejected updates the state consistently.

---

### **Custom Matchers**

You can define your own matcher logic:

```js
const isAuthAction = (action) => action.type.startsWith("auth");

builder.addMatcher(isAuthAction, (state) => {
  state.lastAuthEvent = Date.now();
});
```

This enables powerful cross feature reactions.

---

### **When Matchers Shine**

• Global loading indicators
• Centralized error handling
• Logging or analytics reducers
• Cross feature coordination

---

## **3. Cross Slice Communication**

### **The Problem**

Slices should be independent.
But real systems are not isolated.

Examples:

• Logging out clears multiple slices
• Fetching user data updates auth and profile
• Deleting a post removes its comments

Redux Toolkit allows this **without tight coupling**.

---

### **Pattern 1: Responding to External Actions**

Any slice can respond to another slice’s actions using extraReducers.

```js
builder.addCase(logout, (state) => {
  state.data = [];
});
```

This keeps slices decoupled while still coordinated.

---

### **Pattern 2: Reacting to Async Results**

```js
builder.addCase(fetchUser.fulfilled, (state, action) => {
  state.profile = action.payload;
});
```

The slice does not care who dispatched the action.
It only reacts to the result.

---

### **Pattern 3: RTK Query Matchers**

RTK Query exposes matchers too:

```js
builder.addMatcher(api.endpoints.getUser.matchFulfilled, (state, action) => {
  state.cachedUser = action.payload;
});
```

This lets traditional slices react to server data declaratively.

---

## **4. Putting It Together: A Real Pattern**

Imagine a social app:

• users slice uses entity adapter
• posts slice uses entity adapter
• comments slice depends on posts
• global ui slice tracks loading

You might have:

• Matchers for all pending async actions
• Entity adapters for all collections
• Cross slice reducers for cleanup on logout

Each tool solves a specific scaling problem.
None break Redux’s predictability.

---

## **Evolution and Refinement**

Earlier Redux required:

• Manual normalization
• Manual selector writing
• Action type duplication
• Tight coupling between reducers

Redux Toolkit introduced:

• Entity adapters for structure
• Matchers for declarative reactions
• Slice boundaries with controlled communication

This evolution made Redux viable again for very large applications.

---

## **Principle and Takeaway**

Advanced Redux Toolkit patterns exist for one reason:

**Scale without chaos**

• Entity adapters bring structure
• Matchers bring declarative power
• Cross slice communication brings coordination without coupling

When used together, they allow Redux to scale to hundreds of features while remaining understandable, testable, and predictable.
