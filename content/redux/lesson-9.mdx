---
id: CF-3009
title: Lesson 9 Connecting Redux to React Provider useSelector and useDispatch
classification: UNCLASSIFIED
status: ACTIVE
updatedAt: 2025-12-16T23:18:00.000Z
owner: Frontend Systems Education
role: Curriculum Author
timeframe: 1 lesson
stack:
  - JavaScript
  - React
  - Redux
  - Redux Toolkit
  - React Redux
tags:
  - React Redux
  - Provider
  - useSelector
  - useDispatch
  - State Synchronization
  - UI Integration
summary: Explains how React components connect to the Redux store using Provider useSelector and useDispatch enabling declarative state reading predictable updates and clean unidirectional data flow between UI and global state.
---

# **Lesson 9 — Connecting Redux to React: `Provider`, `useSelector`, and `useDispatch`**

---

## **Context / Motivation**

So far, you’ve learned how Redux organizes and updates state — stores, slices, actions, reducers, middleware, and async thunks.
But none of that matters unless your **React components** can _see_ and _change_ that state.

The goal of this lesson is to connect the elegant architecture of Redux to the _reactive world of React._

In early Redux (before hooks), this required the `connect()` higher-order component.
Today, thanks to the `react-redux` library and React hooks, we have a much cleaner, function-based API:
**`<Provider>`**, **`useSelector`**, and **`useDispatch`**.

These three are the bridge between your Redux store and your UI.

---

## **Conceptual Explanation**

### **1. The Role of `<Provider>`**

At the root of your app, the `Provider` component **injects the Redux store into React’s context**, making it available to all descendants.

```jsx
import { Provider } from "react-redux";
import store from "./store";
import App from "./App";

<Provider store={store}>
  <App />
</Provider>;
```

Think of it as a **bridge** between Redux’s single store and React’s component tree.

Without this, `useSelector` and `useDispatch` wouldn’t know which store to talk to.

**Analogy:**
`Provider` is like a power outlet for your Redux “electricity.”
All components inside can now “plug in” to receive state and dispatch actions.

---

### **2. Reading State: `useSelector()`**

`useSelector` is how React components _read_ data from the Redux store.

```jsx
import { useSelector } from "react-redux";

function UserProfile() {
  const user = useSelector((state) => state.auth.user);

  return <h1>Welcome, {user.name}</h1>;
}
```

- The selector function receives the entire Redux state.
- The component automatically re-renders whenever the selected data changes.
- It subscribes efficiently — React-Redux uses shallow equality to avoid unnecessary re-renders.

**Best practices:**

- Keep selectors small and focused: `state => state.cart.items.length`
- Avoid creating new objects inside selectors — use **memoized selectors** (with `reselect`) for derived data.
- You can create reusable selector functions in each slice file.

Example:

```js
// usersSlice.js
export const selectAllUsers = (state) => state.users.data;
```

Then in components:

```js
const users = useSelector(selectAllUsers);
```

---

### **3. Dispatching Actions: `useDispatch()`**

`useDispatch` returns the store’s `dispatch` method —
your way to _send_ actions (synchronous or asynchronous) to Redux.

```jsx
import { useDispatch } from "react-redux";
import { increment, decrement } from "./counterSlice";

function CounterButtons() {
  const dispatch = useDispatch();

  return (
    <div>
      <button onClick={() => dispatch(increment())}>+</button>
      <button onClick={() => dispatch(decrement())}>−</button>
    </div>
  );
}
```

This works for both:

- **Synchronous actions** from reducers (`increment()`)
- **Asynchronous thunks** (`dispatch(fetchUsers())`)

Each dispatch triggers the middleware chain and reducer updates we’ve already studied.

---

### **4. Putting It All Together**

Let’s combine `useSelector` and `useDispatch` in a full example.

```jsx
import React, { useEffect } from "react";
import { useSelector, useDispatch } from "react-redux";
import { fetchUsers } from "./usersSlice";

function UsersList() {
  const dispatch = useDispatch();
  const { data: users, status, error } = useSelector((state) => state.users);

  useEffect(() => {
    if (status === "idle") dispatch(fetchUsers());
  }, [status, dispatch]);

  if (status === "loading") return <p>Loading...</p>;
  if (status === "failed") return <p>Error: {error}</p>;

  return (
    <ul>
      {users.map((user) => (
        <li key={user.id}>{user.name}</li>
      ))}
    </ul>
  );
}
```

This single component now:

- Reads data (`useSelector`)
- Dispatches async actions (`useDispatch`)
- Automatically re-renders when the store updates

No manual subscriptions, no prop drilling — Redux and React are now seamlessly synchronized.

---

### **5. The Unidirectional Flow in React**

With React connected to Redux, the full flow becomes:

```
User clicks button
     ↓
dispatch(action)
     ↓
middleware (optional)
     ↓
reducer updates store
     ↓
React-Redux detects state change
     ↓
useSelector() re-runs → component re-renders
```

React stays declarative — you never “tell” it to update.
You only change state in Redux, and React responds automatically.

---

## **Real-World Illustration**

Imagine a **product listing** page in an e-commerce site.

- `ProductsList` component displays products → uses `useSelector(state => state.products.data)`
- `AddToCartButton` component adds items → uses `useDispatch()` to call `dispatch(addToCart(product))`
- `CartIcon` in the header shows the number of items → `useSelector(state => state.cart.items.length)`

All three components read from and update the same store.
When one dispatches an action (e.g., adding an item), the others automatically re-render to reflect the new global state — no props, no callbacks, no duplication.

---

## **Evolution / Refinement**

Before React hooks, Redux relied on the `connect()` higher-order component:

```js
export default connect(mapStateToProps, mapDispatchToProps)(MyComponent);
```

While powerful, it introduced extra layers of indirection and verbosity.

Hooks (`useSelector`, `useDispatch`) made Redux **simpler, flatter, and more composable**, aligning it with modern React’s functional component style.

The underlying behavior remains identical — the difference is _ergonomics._

---

## **Principle / Takeaway**

Connecting React to Redux is elegantly minimal:

- **`<Provider>`** → makes the store accessible to React.
- **`useSelector`** → reads data from the store.
- **`useDispatch`** → sends actions to update it.

Everything else — middleware, reducers, async thunks — operates invisibly beneath.

> React renders the _what_, Redux manages the _how_,
> and together they create a predictable loop of state and UI.

---

✅ **Next Lesson Preview – Lesson 10:**
**Selectors, Memoization, and Reselect**
In the next lesson, we’ll go deeper into selectors: how they can compute derived data efficiently, avoid unnecessary re-renders, and scale performance as your state grows.
