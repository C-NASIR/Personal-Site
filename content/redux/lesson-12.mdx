---
id: CF-3012
title: Lesson 12 Structuring a Real Project Folder and Slice Architecture
classification: UNCLASSIFIED
status: ACTIVE
updatedAt: 2025-12-16T23:55:00.000Z
owner: Frontend Systems Education
role: Curriculum Author
timeframe: 1 lesson
stack:
  - JavaScript
  - React
  - Redux
  - Redux Toolkit
tags:
  - Project Architecture
  - Folder Structure
  - Feature Based Design
  - Slice Architecture
  - Scalability
  - Maintainability
summary: Explains how to structure a real world Redux Toolkit project using feature first folder organization with self contained slices thunks selectors and APIs to ensure scalability clarity and long term maintainability.
---

# **Lesson 12 — Structuring a Real Project: Folder & Slice Architecture**

---

## **Context / Motivation**

You now understand how Redux _works_:
slices, thunks, selectors, middleware, and DevTools.

But a professional Redux application isn’t just about logic — it’s about **organization**.
When your app scales to dozens of features, hundreds of actions, and complex async flows, the real challenge becomes:

> “Where should everything live, and how do we keep it maintainable?”

Poor structure leads to “Redux sprawl”: scattered files, circular dependencies, and debugging nightmares.

In this lesson, we’ll explore how to structure a real-world Redux Toolkit project for scalability, clarity, and separation of concerns.

---

## **Conceptual Explanation**

### **1. The Old Way — By Type**

In early Redux, it was common to organize by _file type_:

```
/src
  /actions
    userActions.js
    postActions.js
  /reducers
    userReducer.js
    postReducer.js
  /types
    actionTypes.js
  store.js
```

This worked for tiny apps, but it broke down fast:

- Every feature was split across multiple folders.
- Making one change meant editing 3–4 files.
- Cross-feature coordination (e.g. user + posts) became messy.

The Redux team later advised a better approach:
**feature-first architecture.**

---

### **2. The Modern Way — Feature (Slice) Based**

Redux Toolkit is built for this new structure:
keep each _slice_ (domain or feature) in its own folder with all related logic together.

Example:

```
/src
  /app
    store.js
  /features
    /auth
      authSlice.js
      authThunks.js
      authSelectors.js
    /users
      usersSlice.js
      usersSelectors.js
    /posts
      postsSlice.js
    /cart
      cartSlice.js
  /components
    LoginForm.jsx
    UserList.jsx
    PostFeed.jsx
```

This organization has three key principles:

1. **Each feature owns its state** (e.g., `usersSlice` manages `state.users`)
2. **Slices are self-contained modules** (reducers, thunks, and selectors live together)
3. **The global store only aggregates them** — it doesn’t know their internal details

---

### **3. Anatomy of a Slice Folder**

Let’s look inside one slice (e.g., `features/users`):

```
/users
  usersSlice.js
  usersThunks.js
  usersSelectors.js
  usersAPI.js
```

#### **`usersSlice.js`**

Defines the slice:

```js
import { createSlice } from "@reduxjs/toolkit";
import { fetchUsers } from "./usersThunks";

const usersSlice = createSlice({
  name: "users",
  initialState: { data: [], status: "idle", error: null },
  reducers: {
    clearUsers: (state) => {
      state.data = [];
    },
  },
  extraReducers: (builder) => {
    builder
      .addCase(fetchUsers.pending, (state) => {
        state.status = "loading";
      })
      .addCase(fetchUsers.fulfilled, (state, action) => {
        state.status = "succeeded";
        state.data = action.payload;
      })
      .addCase(fetchUsers.rejected, (state, action) => {
        state.status = "failed";
        state.error = action.error.message;
      });
  },
});

export const { clearUsers } = usersSlice.actions;
export default usersSlice.reducer;
```

#### **`usersThunks.js`**

Encapsulates async logic:

```js
import { createAsyncThunk } from "@reduxjs/toolkit";
import { getUsers } from "./usersAPI";

export const fetchUsers = createAsyncThunk("users/fetchUsers", async () => {
  const response = await getUsers();
  return response.data;
});
```

#### **`usersSelectors.js`**

Keeps data access logic clean:

```js
export const selectAllUsers = (state) => state.users.data;
export const selectUserStatus = (state) => state.users.status;
```

#### **`usersAPI.js`**

Handles real API calls (keeps side effects isolated):

```js
import axios from "axios";
export const getUsers = () => axios.get("/api/users");
```

Now each feature is **independent and reusable**.
If you remove `/users`, nothing else breaks.

---

### **4. The Store Layer**

Your `app/store.js` simply combines slices:

```js
import { configureStore } from "@reduxjs/toolkit";
import authReducer from "../features/auth/authSlice";
import usersReducer from "../features/users/usersSlice";
import postsReducer from "../features/posts/postsSlice";

export const store = configureStore({
  reducer: {
    auth: authReducer,
    users: usersReducer,
    posts: postsReducer,
  },
});
```

This `store.js` file should remain lightweight —
it doesn’t contain business logic or API details, just the app’s map of reducers.

---

### **5. Component Layer — How to Use It**

In components, your code becomes simple and declarative:

```jsx
import { useSelector, useDispatch } from "react-redux";
import { fetchUsers } from "../features/users/usersThunks";
import { selectAllUsers } from "../features/users/usersSelectors";

function UsersList() {
  const dispatch = useDispatch();
  const users = useSelector(selectAllUsers);

  React.useEffect(() => {
    dispatch(fetchUsers());
  }, [dispatch]);

  return (
    <ul>
      {users.map((u) => (
        <li key={u.id}>{u.name}</li>
      ))}
    </ul>
  );
}
```

No complex imports or mixed logic — each feature provides its own clean interface.

---

### **6. Folder Naming Conventions**

| Layer         | Convention                 | Description                     |
| ------------- | -------------------------- | ------------------------------- |
| `app/`        | Global setup               | store, root reducers, constants |
| `features/`   | Each subfolder = one slice | domain-specific logic           |
| `components/` | UI-only components         | reusable across features        |
| `hooks/`      | Custom React hooks         | e.g., `useAuth`, `useFetch`     |
| `utils/`      | Generic helpers            | e.g., formatters, validators    |
| `api/`        | Shared networking code     | base API clients (Axios, Fetch) |

Keep your mental model:

- **Slices** = brains
- **Components** = faces
- **Store** = nervous system connecting them

---

### **7. Example Folder Structure for a Mid-Size App**

```
src/
  app/
    store.js
    rootReducer.js
  features/
    auth/
      authSlice.js
      authThunks.js
      authSelectors.js
      authAPI.js
    posts/
      postsSlice.js
      postsThunks.js
      postsSelectors.js
    comments/
      commentsSlice.js
    notifications/
      notificationsSlice.js
  components/
    Navbar.jsx
    LoginForm.jsx
    PostCard.jsx
    Spinner.jsx
  hooks/
    useAuth.js
  api/
    axiosClient.js
  utils/
    formatDate.js
    debounce.js
  index.js
```

This scales beautifully as your app grows —
you can add or remove features without touching others.

---

## **Real-World Illustration**

Imagine your team is building a **social platform**.
Different developers work on different features:

- Alice → `usersSlice`
- Bob → `postsSlice`
- Carol → `commentsSlice`

Each dev owns a folder, a slice, and related thunks/selectors.
All plug into the same store — no global coupling, no merge conflicts.

When the “notifications” feature launches, it’s just a new folder with a new slice.
Everything integrates cleanly because the architecture is modular by design.

---

## **Evolution / Refinement**

In pre-Toolkit Redux, teams debated endless file structures.
Now, Redux Toolkit’s slice-first model settled it:

> “Organize code by feature, not by type.”

This mirrors the approach of modern frontend architectures (Next.js, Vuex, Recoil).
It aligns your Redux structure with how the product itself is organized — by _domain_.

As apps scale to hundreds of modules, feature isolation and local reasoning become the key to maintainability.

---

## **Principle / Takeaway**

A well-structured Redux app makes complexity manageable.

- **Organize by feature**, not by file type.
- Keep slices **self-contained** (reducers, actions, thunks, selectors together).
- Let the **store** only aggregate.
- Keep **components dumb** — they just read and dispatch.

> When your architecture mirrors your product’s domain structure,
> onboarding becomes easy, debugging becomes fast, and growth stays effortless.

---

✅ **Next Lesson Preview – Lesson 13:**
**RTK Query — Data Fetching and Caching Made Easy**
In the next lesson, we’ll go beyond `createAsyncThunk()` and explore RTK Query, Redux Toolkit’s built-in solution for automatic data fetching, caching, and synchronization with the backend.
